'use strict';

module.exports = {
  conditions: [''],
  name: 'Script',
  rules: ['ScriptBody'],
  handlers: ['\n      $$ = new (require(\'./ast/ScriptNode\'))($1, { loc: this._$, yy });\n      $$.sourceType = $1.sourceType;\n      if (yy.comments) {\n        for (let i = 0; i < yy.comments.length; i++) {\n          const comments = yy.comments;\n          const comment = comments[i];\n          if (yy.comments[i].leadingLinkNode) {\n            yy.comments[i].leadingLinkNode.leadingComments.push({\n              type: comment.type,\n              value: comment.buffer.join(\'\'),\n              range: [comment.range[0], comment.range[1]],\n            });\n            comment.hasLinked = true;\n          }\n          if (yy.comments[i].trailingLinkNode) {\n            yy.comments[i].trailingLinkNode.trailingComments.push({\n              type: comment.type,\n              value: comment.buffer.join(\'\'),\n              range: [comment.range[0], comment.range[1]],\n            });\n            comment.hasLinked = true;\n          }\n        }\n        // NOTICE:\n        // still some comments will not link to the ast node\n        // (e.g, "return /*comment*/ ;", comments in the end)\n        // here simply put all these comments to the root node\n\n        for (let i = 0; i < yy.comments.length; i++) {\n          const comments = yy.comments;\n          const comment = comments[i];\n\n          if (!comment.hasLinked) {\n            $$.trailingComments.push({\n              type: comment.type,\n              value: comment.buffer.join(\'\'),\n              range: [comment.range[0], comment.range[1]],\n            });\n          }\n        }\n      }\n      return $$;\n    '],
  subRules: [require('./ScriptBody')]
};